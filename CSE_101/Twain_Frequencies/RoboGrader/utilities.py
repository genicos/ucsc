import subprocess
import os

###############################
###############################
# function generate_file
# Input:
#     goto_folder: string, folder to run command in
#     return_to_folder: string, folder to return to
#     filename: string, name of file to be generated
#     prod_command: string, command that produces file
#     timeout_thresh: int, timeout threshold in seconds
# Output: [success, message]
#     success: Boolean, true is executable generated correctly, false otherwise
#     message: log message explaining possible error in case success if false
# 
# The function enters goto_folder, and runs a command to produce the executable, as specified in the arguments. It has a timeout threshold as specified. 
# 
###############################

def generate_file(goto_folder, return_to_folder, filename, prod_command, timeout_thresh):
    command_list = prod_command.split(' ') # subprocess.run requires command to be a list, where first argument is command, rest are arguments
    os.chdir(goto_folder) # move into solution folder

    log = '' # log message to be returned
    success = True

    if '>' in command_list or '<' in command_list or '|' in command_list: # some piping involved in command
        try:
            os.system(prod_command) # need to us os.system, since subprocess won't work
        except Exception as e: # some error in running
            log = log + 'Error in running command: '+prod_command+'\n'
            log = log + 'Python exception: '+str(e)+'\n'
            success = False # failure
    else: # no piping, so use subprocess.run
        try:
            subprocess.run(command_list,timeout=timeout_thresh) # run command in terminal, with given timeout_thresh
        except subprocess.TimeoutExpired: # timeout error in producing executable
            log = log + 'Timeout error in running '+prod_command+': Took more than '+str(timeout_thresh)+' seconds\n' # add to message and command
            success = False # failure
    
        except Exception as e: # some error in command
            log = log + 'Error in running command: '+prod_command+'\n'
            log = log + 'Python exception: '+str(e)+'\n'         
            success = False # failure

    # command worked, so some executable was produced
    if success and filename not in os.listdir(): # check if file was produced
        log = log + 'Error: file '+filename+' is not created by running command '+prod_command+'\n' # print error message
        success = False # failure

    os.chdir(return_to_folder) # return to folder, as specified in arguments
    return [success, log]

###############################

###############################
###############################
# function check_equality
# Input:
#         output: string, name of output file, as generated by solution
#         ideal: string, name of ideal file
# Output: [success, message]
#         success: Boolean, true if files are identical, false otherwise
#         message: string. If files are not identical, this contains an explanation of how they are different
# 
# This function basically runs through each file line by line and checks equality.
#
############################### 

def check_equality(output,ideal):
    f_output = open(output,'r') # open output file and ideal files
    f_ideal = open(ideal,'r')

    output_lines = f_output.readlines() # lines of output file
    ideal_lines = f_ideal.readlines() # lines of ideal file

    output_len = len(output_lines) # no. of lines in output file
    ideal_len = len(ideal_lines) # no. of lines in ideal file

    success = True # initialize output values
    log = ''

    # loop over ideal file, and check with each line in output file

    for i in range(0,ideal_len): # looping over smaller file
        if output_len <= i: # output file is too small
            log = log + "Error in output generation. The output file, "+str(output)+", generated by your program has "+str(output_len)+" lines\n"
            log = log + "The correct output file has "+str(ideal_len)+" lines\n"
            log = log + "The following line should be present at line "+str(output_len)+" of your output. But it is not.\n"
            log = log + ideal_lines[output_len]+'\n'
            success = False # failure
            break # exit for loop

        # at the points, output_lines[i] must exist
        if output_lines[i].strip().split() != ideal_lines[i].strip().split(): # take the lines, tokenize by whitespace, and check that the resulting lists are equal
            log = log+"Error in output generation. Your program is wrong on a test case. Specifically, mismatch at line "+str(i)+'. (Line numbers start at 0.)\n'
            log = log + "In output file, "+output+", generated by your program, line is: "+output_lines[i]+'\n'
            log = log + "In correct output file, line is: "+ideal_lines[i]+'\n'
            success = False # failure
            break # exit for loop

    return [success, log]

###################################

###################################
###################################
# function verify_output
# Input:
#     verifier: string, command that runs verifier
#     output: string, output file as produced by solution
#     test: string, test file corresponding to this output
#     ideal: string, ideal output file for this test file
# Output: [success, message]
#      success: Boolean, true if verifier run, false otherwise
#      message: string, some message to explaining why success is false
# 
# This function runs the verifier with these arguments. This should produce a log file, verifier.log, that can be processed.
# 
###################################

def verify_output(verifier, output, test, ideal):
    command_string = verifier+' '+output+' '+test+' '+ideal
    command_list = command_string.split(' ') # subprocess.run needs a list of strings, with each argument as separate element in list
    print('Running: ')
    print(command_list)

    success = True
    message = ''
    try:
        subprocess.run(command_list) # run command in terminal
    except Exception as e: # some error in verifier
        success = False
        message = 'Some problem in running command:\n'+command_string+'\n'+'Python exception: '+str(e)
    return [success, message]

